Структура программы.

Запускать программу мы научились, теперь рассмотрим код из листинга 1.2 по-строчно. В первых строках подключаются необходимые заголовочные файлы: 
#include <QApplication> 
#include <QWidget> 
#include <QLabel> 
#include <QPushButton> 
#include <QVBoxLayout>

Далее определяется функция main(), которая является точкой входа в приложение. Через первый параметр (argc) доступно количество аргументов, переданных в ко-мандной строке. Следует учитывать, что первым аргументом является название исполняемого файла, поэтому значение параметра argc не может быть меньше еди-ницы. Через второй параметр (argv) доступны все аргументы в виде строки (тип char *). Квадратные скобки после названия второго параметра означают, что дос-тупен массив строк. 

Инструкция		QApplication app(argc, argv);		
создает объект приложения с помощью класса QApplication. Конструктор этого класса принимает количество и список параметров, переданных в командной стро-ке. Следует помнить, что в программе всегда должен быть объект приложения, причем обязательно только один. Может показаться, что после создания он больше нигде не используется в программе, однако с помощью этого объекта осуществля-ется управление приложением незаметно для нас. Получить доступ к этому объекту из любого места в программе можно через макрос qApp, который преобразуется в указатель на объект приложения. Например, вывести список параметров, пере-данных в командной строке, можно так: 
qDebug() << qApp->arguments();
Результат при запуске программы:
QList("C:\\cpp\\projectsQt\\Test-Debug\\debug\\Test.exe")

Следующая инструкция:		QWidget window;
создает объект окна с помощью класса QWidget. Этот класс наследуют практически все классы, реализующие компоненты графического интерфейса. Поэтому любой компонент, не имеющий родителя, обладает своим собственным окном. 

Инструкция		window.setWindowTitle("Первая программа на Qt");
задает текст, который будет выводиться в заголовке окна.

Инструкция		window.resize(300, 70);
задает предпочтительные размеры окна. В первом параметре метода resize() ука-зывается ширина окна, а во втором параметре — высота окна. Следует учитывать, что эти размеры не включают высоту заголовка окна и ширину границ, а также являются рекомендацией, т. е. если компоненты не помещаются, размеры окна будут увеличены. 

Инструкция		QLabel *label = new QLabel("<center>Привет, мир!</center>");
создает объект надписи. Текст надписи задается в качестве параметра в конструк-торе класса QLabel. Обратите внимание на то, что внутри строки мы указали HTML-теги. В данном примере с помощью тега <center> произвели выравнивание текста по центру компонента. Возможность использования HTML-тегов и CSS-атрибутов является отличительной чертой библиотеки Qt. Например, внутри надписи можно вывести таблицу или изображение. Это очень удобно.
 
Инструкция		QPushButton *btnQuit = new QPushButton("&Закрыть окно");
создает объект кнопки. Текст, который будет отображен на кнопке, задается в каче-стве параметра в конструкторе класса QPushButton. Обратите внимание на символ & перед буквой З. Таким образом задаются клавиши быстрого доступа. Если нажать одновременно клавишу <Alt> и клавишу с буквой, перед которой в строке указан символ &, то кнопка будет нажата.
 
Инструкция		QVBoxLayout *vbox = new QVBoxLayout();
создает вертикальный контейнер. Все компоненты, добавляемые в этот контейнер, будут располагаться друг под другом в порядке добавления. Внутри контейнера автоматически производится подгонка размеров добавляемых компонентов под размеры контейнера. При изменении размеров контейнера будет произведено из-менение размеров всех компонентов.

В следующих двух инструкциях: 
vbox->addWidget(label); 
vbox->addWidget(btnQuit);
с помощью метода addWidget() производится добавление объектов надписи и кноп-ки в вертикальный контейнер. Так как объект надписи добавляется первым, он будет расположен над кнопкой. При добавлении в контейнер компоненты авто- матически становятся потомками контейнера.
 
Инструкция		window.setLayout(vbox);
добавляет контейнер в основное окно с помощью метода setLayout(). Таким обра-зом, контейнер становится потомком основного окна.
 
Инструкция		QObject::connect(btnQuit, SIGNAL(clicked()),&app, SLOT(quit()));
назначает обработчик сигнала clicked(), который генерируется при нажатии кноп-ки. В первом параметре статического метода connect() передается указатель на объект, генерирующий сигнал, а во втором параметре, с помощью макроса SIGNAL(), — название сигнала. В третьем параметре передается указатель на объект, принимающий сигнал, а в четвертом параметре — метод этого объекта, который будет вызван при наступлении события. Метод указывается в качестве параметра макроса SLOT(). Этот метод принято называть слотом. В нашем примере получате-лем сигнала является объект приложения, доступный также через указатель qApp. При наступлении события будет вызван метод quit(), который завершит работу всего приложения. Пример указания макроса qApp: 
QObject::connect(btnQuit, SIGNAL(clicked()),qApp, SLOT(quit()));

Следующая инструкция:		window.show();
отображает окно и все компоненты, которые мы ранее добавили.

И наконец, инструкция		return app.exec();
запускает бесконечный цикл обработки событий. Инструкции, расположенные по-сле вызова метода exec(), будут выполнены только после завершения работы при-ложения. Так как результат выполнения метода exec() мы возвращаем из функции main(), дальнейшее выполнение программы будет прекращено, а код возврата пе-редан операционной системе. 